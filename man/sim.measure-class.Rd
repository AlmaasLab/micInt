% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim_measure_class.R
\docType{class}
\name{sim.measure-class}
\alias{sim.measure-class}
\alias{sim.measure}
\title{Similarity measure}
\usage{
sim.measure(
  FUN,
  string,
  categorical = FALSE,
  mean_scaleable = FALSE,
  signed = FALSE,
  type = "parametric"
)
}
\arguments{
\item{FUN}{The similarity measure function to use, of the form \code{f(x,y)}.
The function must satisfy the following: \itemize{
\item If \code{x} and \code{y} are both given, they are treated as vectors and the
similarity score between them is returned
\item If only \code{x} is given, it is treated as a matrix (or data frame) where the
features are in columns and sample in the rows. The function must then return
the matrix of pairwise similarities
\item The function must return a similarity score in the interval [0,1], where 1 is
perfect similarity and 0 is perfect dissimilarity. Alternativly, signed similarity scores
in the interval [-1,1] can also be used.
}}

\item{string}{The similarity score's human readable name.}

\item{categorical}{Logical value indicating whether the function only
considers presence-absence of an OTU. If \code{TRUE}, the function will not be
noisified as there is no point in adding noise to the data.}

\item{mean_scaleable}{Logical value telling whether it makes sense to scale the input by its
mean before applying this function}

\item{signed}{If \code{TRUE}, the similarity measures gives signed results in the interval [-1,1],
else they are in the interval [0,1].}

\item{type}{Character; the way the similarity measure processes the information. On of: \itemize{
\item \code{"presence-absence"} Measures the similarity of OTUs solely by their presence-absence
pattern
\item \code{"non-parametric"} Measures the similarity based on the rank pattern, but besides this,
no other information on the abudandances are used
\item \code{"parameteric"} The actual values of the abundances matter in the calulations
}}
}
\description{
A similarity measure structure with the function ifself, and metadata fields
}
\section{Slots}{

\describe{
\item{\code{FUN}}{The similarity measure function to use, of the form \code{f(x,y)}.
The function must satisfy the following: \itemize{
\item If \code{x} and \code{y} are both given, they are treated as vectors and the
similarity score between them is returned
\item If only \code{x} is given, it is treated as a matrix (or data frame) where the
features are in columns and sample in the rows. The function must then return
the matrix of pairwise similarities
\item The function must return a similarity score in the interval [0,1], where 1 is
perfect similarity and 0 is perfect dissimilarity. Alternativly, signed similarity scores
in the interval [-1,1] can also be used.
}}

\item{\code{string}}{The similarity score's human readable name.}

\item{\code{categorical}}{Logical value indicating whether the function only
considers presence-absence of an OTU. If \code{TRUE}, the function will not be
noisified as there is no point in adding noise to the data.}

\item{\code{mean_scaleable}}{Logical value telling whether it makes sense to scale the input by its
mean before applying this function}

\item{\code{signed}}{If \code{TRUE}, the similarity measures gives signed results in the interval [-1,1],
else they are in the interval [0,1].}

\item{\code{type}}{Character; the way the similarity measure processes the information. On of: \itemize{
\item \code{"presence-absence"} Measures the similarity of OTUs solely by their presence-absence
pattern
#' \item \code{"non-parametric"} Measures the similarity based on the rank pattern, but besides this,
no other information on the abudandances are used
\item \code{"parameteric"} The actual values of the abundances matter in the calulations
}}
}}

\examples{
# This measures how well the arguments agree with the signs
# This primary function accept two vectors only
my_measure_simple <- function(x,y){
 (sum((x > 0) & (y > 0)) + sum((x < 0) & (y < 0))) /
  (sum(x > 0) + sum(x < 0))
}
# We extend this function into acception a matrix argument when y is now supplied
my_measure <- function(x,y=NULL){
if(is.null(y)){
n_vectors <- ncol(x)
res <- matrix(NA_real_,n_vectors,n_vectors)
for (i in seq_len(n_vectors)){
    for(j in seq_len(n_vectors)){
    res[i,j] <- my_measure_simple(x[,i],x[,j])
    }
}
    res

}
else{
my_measure_simple(x,y)
}
}

my_sim_score <-sim.measure(my_measure,string= "My measure", categorical = FALSE,
 mean_scaleable = FALSE, signed = FALSE, type = "non-paramtric")
sim_fun <- sim_measure_function(my_sim_score)
sim_fun(c(1,0,-1),c(2,-1,-1))
sim.measure.attributes(my_sim_score)

}
\seealso{
\link{noisify}
}
